# RustでのLambdaとCloud Run向け分岐コンパイルを行うライブラリ実装計画

## 目的
- AWS Lambda向けとGoogle Cloud Run向けに、異なるコンパイル設定で動作するRustライブラリを作成する。
- ユーザー体験は、acrix-web（あるいはactix-webに似た操作感）を目指す。
- 単一のコードベースでプラットフォーム固有の処理を分離し、Cargo featureによりビルド時にどちらのターゲットにするかを決定する。
- 環境特有の設定（タイムアウトや接続設定など）は環境変数によって管理する。

## 機能概要
1. **共通の抽象化レイヤー:**
   - リクエスト/レスポンスの抽象型定義
   - actix-webに類似したルーティング定義とミドルウェアによる拡張性を持つAPI設計
   - 共通のエラーハンドリングとして、`log`クレートを用いた一元的なログ出力を実施

2. **AWS Lambda向け実装 (`#[cfg(feature = "lambda")]`):**
   - `aws_lambda_events`、`lambda_runtime`など、Lambdaに対応したクレートの導入
   - API Gatewayなどから渡されるLambdaイベントを処理する仕組みを実装し、共通のハンドラに変換する

3. **Google Cloud Run向け実装 (`#[cfg(feature = "cloud_run")]`):**
   - 一般的なHTTPサーバー（例: actix-web、hyper、Rocketなど）を利用し、HTTPリクエストを処理する仕組みを実装
   - Cloud Run固有の設定やデプロイ時の最適化を考慮

4. **開発者体験（APIデザイン）:**
   - シンプルかつ拡張性の高いルーティング定義・ミドルウェアの仕組みを提供し、actix-webに似た操作感を実現
   - エラーハンドリングは`log`クレートを用い、統一性と可視性を確保

## プロジェクト構成例 
project_root/
├── Cargo.toml
└── src/
├── lib.rs // 共通の抽象化レイヤーおよびエントリポイント
├── lambda.rs // AWS Lambda向けの実装（feature "lambda"）
├── cloudrun.rs // Google Cloud Run向けの実装（feature "cloud_run"）
└── common/ // 共通処理やユーティリティ
└── mod.rs

## Cargo.tomlの設定案
- [dependencies] セクションで、共通依存（例: tokio, serde, log）を定義
- [features] セクションに `lambda` と `cloud_run` の２つのfeatureを定義し、ビルド時にどちらを有効にするかを決定
- 各featureごとに必要なクレート（例: `lambda_runtime`、`aws_lambda_events`、`actix-web`など）をオプション依存として設定

## 実装ステップ
1. **API設計:**
   - actix-webに似たルーティング定義と、ミドルウェアで拡張可能なAPIの設計
   - 共通のTraitや型を定義し、プラットフォームごとの実装間で統一性を確保する

2. **Lambda側の実装 (`lambda.rs`):**
   - `#[cfg(feature = "lambda")]` を用いてコードを分岐
   - API Gatewayなどからのイベントを受け取り、共通のハンドラに変換する仕組みの実装

3. **Cloud Run側の実装 (`cloudrun.rs`):**
   - `#[cfg(feature = "cloud_run")]` を用いてコードを分岐
   - HTTPリクエストを起点としたルーティング、ハンドラ呼び出しの実装

4. **設定管理:**
   - 各種環境依存の設定（タイムアウト、接続設定など）は環境変数で管理する仕組みを実装

5. **テストとドキュメンテーション:**
   - 各機能のユニットテストおよび統合テストを行い、LambdaとCloud Runの双方で動作確認を実施
   - API使用例（サンプルコード）、設定方法などのドキュメントを整備

## 疑問点への回答と反映
1. **ルーティング & ミドルウェアの使用:**  
   - actix-webに似た操作感を目指し、ルーティング定義およびミドルウェアの仕組みを採用する。  
   - エラーハンドリングは`log`クレートを利用して統一的に行う。

2. **処理モデルの確定:**  
   - Cloud Run向けはHTTPリクエストベースの処理に特化させる。  
   - Lambda向けは、API Gateway等からのイベント受信を想定して実装する。

3. **環境変数での設定管理:**  
   - 各プラットフォーム固有の設定は、実行環境変数で管理する方針とする。

4. **ビルド時の決定:**  
   - Cargo featureにより、ビルド時にどちらの環境向けかを明確に切り替える。

5. **包括的なテスト:**  
   - Lambda、Cloud Run双方での動作確認ができるよう、網羅的なユニットテストと統合テストを実施する。

## 今後のステップ
- 上記疑問点への回答内容に沿って、詳細なAPI設計と各モジュールの実装方針を固める。
- 要件が明確になり次第、それぞれのターゲット向けにモジュールごとの実装に着手する。
